This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-31T12:58:46.292Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cmd/
  gochat/
    main.go
internal/
  chat/
    message.go
  config/
    config.go
  llm/
    client.go
  ui/
    app_model.go
    chat_view.go
    finder_view.go
    input_view.go
    styles.go
.air.toml
.cursorrules
config.yaml
go.mod
Makefile

================================================================
Files
================================================================

================
File: cmd/gochat/main.go
================
package main

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/saiashirwad/gochat/internal/config"
	"github.com/saiashirwad/gochat/internal/ui"
)

func main() {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		fmt.Printf("Error loading config: %v\n", err)
		os.Exit(1)
	}

	// Create and start the Bubble Tea program
	p := tea.NewProgram(
		ui.NewAppModel(cfg),
		tea.WithAltScreen(),       // Use alternate screen buffer
		tea.WithMouseCellMotion(), // Enable mouse support
	)

	if _, err := p.Run(); err != nil {
		fmt.Printf("Error running program: %v\n", err)
		os.Exit(1)
	}
}

================
File: internal/chat/message.go
================
package chat

import "time"

// Role represents the role of a message sender (user or assistant)
type Role string

const (
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
)

// Message represents a chat message
type Message struct {
	Role      Role      `json:"role"`
	Content   string    `json:"content"`
	Timestamp time.Time `json:"timestamp"`
}

// NewMessage creates a new message
func NewMessage(role Role, content string) Message {
	return Message{
		Role:      role,
		Content:   content,
		Timestamp: time.Now(),
	}
}

================
File: internal/config/config.go
================
package config

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/viper"
)

// Config holds the application configuration
type Config struct {
	LLM struct {
		Provider  string `mapstructure:"provider"`
		Model     string `mapstructure:"model"`
		APIKey    string `mapstructure:"api_key"`
		Endpoint  string `mapstructure:"endpoint"`
		MaxTokens int    `mapstructure:"max_tokens"`
	} `mapstructure:"llm"`

	UI struct {
		Theme         string `mapstructure:"theme"`
		MaxWidth      int    `mapstructure:"max_width"`
		ShowTimestamp bool   `mapstructure:"show_timestamp"`
	} `mapstructure:"ui"`

	Storage struct {
		ChatsDir string `mapstructure:"chats_dir"`
	} `mapstructure:"storage"`
}

// Load reads the configuration from a file and environment variables
func Load() (*Config, error) {
	v := viper.New()

	// Set default values
	v.SetDefault("llm.provider", "openai")
	v.SetDefault("llm.model", "gpt-3.5-turbo")
	v.SetDefault("llm.max_tokens", 2000)
	v.SetDefault("ui.max_width", 100)
	v.SetDefault("ui.show_timestamp", true)
	v.SetDefault("storage.chats_dir", "chats")

	// Config file settings
	v.SetConfigName("config")
	v.SetConfigType("yaml")
	v.AddConfigPath(".")
	v.AddConfigPath("configs/")
	v.AddConfigPath("$HOME/.config/gochat/")

	// Environment variables
	v.AutomaticEnv()
	v.SetEnvPrefix("GOCHAT")

	// Read config file
	if err := v.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
		// Config file not found, using defaults and env vars
	}

	// Special handling for API key from environment
	if key := os.Getenv("GOCHAT_LLM_API_KEY"); key != "" {
		v.Set("llm.api_key", key)
	}

	// Create chat directory if it doesn't exist
	chatsDir := v.GetString("storage.chats_dir")
	if err := os.MkdirAll(chatsDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create chats directory: %w", err)
	}

	// Convert absolute paths if needed
	if !filepath.IsAbs(chatsDir) {
		absPath, err := filepath.Abs(chatsDir)
		if err == nil {
			v.Set("storage.chats_dir", absPath)
		}
	}

	var cfg Config
	if err := v.Unmarshal(&cfg); err != nil {
		return nil, fmt.Errorf("unable to decode config: %w", err)
	}

	return &cfg, nil
}

================
File: internal/llm/client.go
================
package llm

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/saiashirwad/gochat/internal/chat"
	"github.com/saiashirwad/gochat/internal/config"
)

// APIError represents an error response from the API
type APIError struct {
	Error struct {
		Message string `json:"message"`
		Type    string `json:"type"`
		Code    string `json:"code"`
	} `json:"error"`
}

// Client handles communication with the LLM API
type Client struct {
	config     *config.Config
	httpClient *http.Client
}

// NewClient creates a new LLM client
func NewClient(cfg *config.Config) *Client {
	return &Client{
		config:     cfg,
		httpClient: &http.Client{},
	}
}

type chatRequest struct {
	Model    string        `json:"model"`
	Messages []chatMessage `json:"messages"`
	Stream   bool          `json:"stream"`
}

type chatMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type chatResponse struct {
	ID      string   `json:"id"`
	Object  string   `json:"object"`
	Created int64    `json:"created"`
	Choices []choice `json:"choices"`
}

type choice struct {
	Index   int     `json:"index"`
	Message message `json:"message"`
}

type message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// SendMessage sends a message to the LLM and returns the response
func (c *Client) SendMessage(messages []chat.Message) (string, error) {
	// Convert messages to API format
	apiMessages := make([]chatMessage, len(messages))
	for i, msg := range messages {
		apiMessages[i] = chatMessage{
			Role:    string(msg.Role),
			Content: msg.Content,
		}
	}

	// Create request body
	reqBody := chatRequest{
		Model:    c.config.LLM.Model,
		Messages: apiMessages,
		Stream:   false,
	}

	// Marshal request body
	jsonBody, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("error marshaling request: %w", err)
	}

	// Create request
	req, err := http.NewRequest("POST", c.config.LLM.Endpoint, bytes.NewBuffer(jsonBody))
	if err != nil {
		return "", fmt.Errorf("error creating request: %w", err)
	}

	// Add headers
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+c.config.LLM.APIKey)

	// Send request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("error sending request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading response: %w", err)
	}

	// Check status code
	if resp.StatusCode != http.StatusOK {
		// Try to parse error response
		var apiErr APIError
		if err := json.Unmarshal(body, &apiErr); err == nil {
			return "", fmt.Errorf("API error: %s (type: %s, code: %s)",
				apiErr.Error.Message,
				apiErr.Error.Type,
				apiErr.Error.Code)
		}
		return "", fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
	}

	// Parse response
	var chatResp chatResponse
	if err := json.Unmarshal(body, &chatResp); err != nil {
		return "", fmt.Errorf("error parsing response: %w", err)
	}

	// Return first choice content
	if len(chatResp.Choices) == 0 {
		return "", fmt.Errorf("no response from LLM")
	}

	return chatResp.Choices[0].Message.Content, nil
}

================
File: internal/ui/app_model.go
================
package ui

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/saiashirwad/gochat/internal/config"
)

// AppModel is the main application model
type AppModel struct {
	config        *config.Config
	chatView      *ChatView
	inputView     *InputView
	finderActive  bool
	finderView    *FinderView
	width, height int
}

// NewAppModel creates a new instance of the application model
func NewAppModel(cfg *config.Config) *AppModel {
	return &AppModel{
		config:       cfg,
		chatView:     NewChatView(cfg),
		inputView:    NewInputView(cfg),
		finderActive: false,
		finderView:   NewFinderView(cfg),
	}
}

// Init initializes the model
func (m *AppModel) Init() tea.Cmd {
	return nil
}

// Update handles events and updates the model
func (m *AppModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c":
			return m, tea.Quit
		case "ctrl+f":
			// Toggle finder
			m.finderActive = !m.finderActive
			if m.finderActive {
				// Initialize finder search
				return m, m.finderView.Init()
			}
		case "i":
			// Return to input mode if in chat focus mode
			if !m.inputView.focused {
				m.inputView.Focus()
				m.chatView.focusActive = false
			}
		}

	case tea.WindowSizeMsg:
		m.width, m.height = msg.Width, msg.Height

		// Calculate heights
		inputHeight := 1                     // Input box height (just content, no borders)
		chatHeight := m.height - inputHeight // No extra space needed
		if chatHeight < 5 {
			chatHeight = 5 // Minimum chat height
		}

		// Update sub-component sizes
		m.chatView.SetSize(msg.Width, chatHeight)
		m.inputView.SetWidth(msg.Width)
		m.finderView.SetSize(msg.Width, msg.Height)
	}

	// Handle updates for sub-components
	if m.finderActive {
		// Update finder
		newFinderModel, cmd := m.finderView.Update(msg)
		if newModel, ok := newFinderModel.(*FinderView); ok {
			m.finderView = newModel
		}
		cmds = append(cmds, cmd)
	} else {
		// Update chat view
		newChatModel, cmd := m.chatView.Update(msg)
		if newModel, ok := newChatModel.(*ChatView); ok {
			m.chatView = newModel
		}
		cmds = append(cmds, cmd)

		// Update input view
		newInputModel, cmd := m.inputView.Update(msg)
		if newModel, ok := newInputModel.(*InputView); ok {
			m.inputView = newModel
		}
		cmds = append(cmds, cmd)
	}

	return m, tea.Batch(cmds...)
}

// View renders the UI
func (m *AppModel) View() string {
	if m.finderActive {
		return m.finderView.View()
	}

	// Join views without extra spacing
	return lipgloss.JoinVertical(
		lipgloss.Left,
		m.chatView.View(),
		m.inputView.View(),
	)
}

================
File: internal/ui/chat_view.go
================
package ui

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/glamour"
	"github.com/charmbracelet/lipgloss"
	"github.com/saiashirwad/gochat/internal/chat"
	"github.com/saiashirwad/gochat/internal/config"
	"github.com/saiashirwad/gochat/internal/llm"
)

var (
	// Style for the entire chat area - no borders
	chatStyle = lipgloss.NewStyle()

	// Base message style - minimal with just a separator line
	baseMessageStyle = lipgloss.NewStyle().
				BorderBottom(true).
				BorderStyle(lipgloss.NormalBorder()).
				Width(100)

	// Style for user messages - pink separator
	userMessageStyle = baseMessageStyle.Copy().
				BorderForeground(lipgloss.Color("205"))

	// Style for LLM messages - blue separator
	llmMessageStyle = baseMessageStyle.Copy().
			BorderForeground(lipgloss.Color("39"))

	// Style for focused message - highlighted separator
	focusedMessageStyle = baseMessageStyle.Copy().
				BorderForeground(lipgloss.Color("99"))

	// Header styles - minimal
	headerStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("244"))

	// Markdown renderer
	markdownRenderer *glamour.TermRenderer
)

func init() {
	// Initialize markdown renderer with dark theme
	var err error
	markdownRenderer, err = glamour.NewTermRenderer(
		glamour.WithAutoStyle(),
		glamour.WithWordWrap(0), // Will be set dynamically based on width
	)
	if err != nil {
		panic(err)
	}
}

// ChatView displays the conversation history
type ChatView struct {
	config      *config.Config
	messages    []chat.Message
	llmClient   *llm.Client
	viewport    viewport.Model
	width       int
	height      int
	focusIndex  int  // Index of currently focused message
	focusActive bool // Whether message focus is active
}

// NewChatView creates a new chat view
func NewChatView(cfg *config.Config) *ChatView {
	c := &ChatView{
		config:    cfg,
		llmClient: llm.NewClient(cfg),
		messages: []chat.Message{
			chat.NewMessage(chat.RoleAssistant, "Welcome to GoChat! Type your message below and press Enter to send."),
		},
	}

	// Initialize viewport with minimum size
	c.viewport = viewport.New(10, 10)
	c.viewport.Style = lipgloss.NewStyle()

	return c
}

// SetSize updates the size of the chat view
func (c *ChatView) SetSize(width, height int) {
	c.width = width
	c.height = height
	c.viewport.Width = width
	c.viewport.Height = height
	chatStyle = chatStyle.Width(width)

	// Calculate message width to fill the viewport
	messageWidth := width - 4 // Account for left and right margins
	baseMessageStyle = baseMessageStyle.Width(messageWidth).MaxWidth(messageWidth)
	userMessageStyle = userMessageStyle.Width(messageWidth).MaxWidth(messageWidth)
	llmMessageStyle = llmMessageStyle.Width(messageWidth).MaxWidth(messageWidth)
	focusedMessageStyle = focusedMessageStyle.Width(messageWidth).MaxWidth(messageWidth)
	headerStyle = headerStyle.Width(messageWidth).MaxWidth(messageWidth)

	// Update markdown renderer with new width
	markdownRenderer, _ = glamour.NewTermRenderer(
		glamour.WithAutoStyle(),
		glamour.WithWordWrap(messageWidth-4), // Account for padding
	)

	// Update content after resize
	c.updateContent()
}

// Init initializes the chat view
func (c *ChatView) Init() tea.Cmd {
	return nil
}

// sendMessageCmd creates a command to send a message to the LLM
func sendMessageCmd(client *llm.Client, messages []chat.Message) tea.Cmd {
	return func() tea.Msg {
		response, err := client.SendMessage(messages)
		if err != nil {
			return errMsg{err}
		}
		return newMessageMsg{
			message: chat.NewMessage(chat.RoleAssistant, response),
		}
	}
}

// Message types
type newMessageMsg struct {
	message chat.Message
}

type errMsg struct {
	err error
}

// Message type for focusing chats
type focusChatsMsg struct{}

// Update handles events for the chat view
func (c *ChatView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		if c.focusActive {
			switch msg.String() {
			case "j", "tab":
				c.focusIndex++
				if c.focusIndex >= len(c.messages) {
					c.focusIndex = 0
				}
				c.updateContent()
			case "k", "shift+tab":
				c.focusIndex--
				if c.focusIndex < 0 {
					c.focusIndex = len(c.messages) - 1
				}
				c.updateContent()
			case "esc":
				c.focusActive = false
				c.updateContent()
			}
		}

	case newMessageMsg:
		c.messages = append(c.messages, msg.message)
		c.updateContent()
		return c, nil
	case errMsg:
		c.messages = append(c.messages, chat.NewMessage(chat.RoleAssistant, fmt.Sprintf("Error: %v", msg.err)))
		c.updateContent()
		return c, nil
	case userInputMsg:
		// Add user message to history
		userMessage := chat.NewMessage(chat.RoleUser, msg.input)
		c.messages = append(c.messages, userMessage)
		c.updateContent()
		// Send to LLM
		return c, sendMessageCmd(c.llmClient, c.messages)
	case focusChatsMsg:
		c.focusActive = true
		c.focusIndex = len(c.messages) - 1
		c.updateContent()
	}

	// Handle viewport messages
	c.viewport, cmd = c.viewport.Update(msg)
	return c, cmd
}

// updateContent updates the viewport content with formatted messages
func (c *ChatView) updateContent() {
	var formattedMessages []string
	var totalHeight int

	// First pass: format messages and calculate heights
	messageHeights := make([]int, len(c.messages))
	for i, msg := range c.messages {
		var content string
		var style lipgloss.Style

		// Render content as markdown
		rendered, err := markdownRenderer.Render(msg.Content)
		if err != nil {
			rendered = msg.Content // Fallback to plain text if markdown rendering fails
		}
		rendered = strings.TrimSpace(rendered) // Remove extra newlines from glamour

		// Add header based on role
		header := "LLM Message"
		if msg.Role == chat.RoleUser {
			header = "My message"
		}
		header = headerStyle.Render(header)

		// Join header and content without padding
		content = lipgloss.JoinVertical(lipgloss.Left, header, rendered)

		// Apply appropriate style based on role and focus
		if c.focusActive && i == c.focusIndex {
			style = focusedMessageStyle
		} else if msg.Role == chat.RoleUser {
			style = userMessageStyle
		} else {
			style = llmMessageStyle
		}

		// Apply the style and add to messages
		formattedMsg := style.Render(content)
		formattedMessages = append(formattedMessages, formattedMsg)

		// Calculate height of this message (count newlines + 1)
		height := strings.Count(formattedMsg, "\n") + 1
		messageHeights[i] = height
		totalHeight += height
	}

	// Join messages and set content
	content := strings.Join(formattedMessages, "\n")
	c.viewport.SetContent(content)

	// Adjust scrolling only when necessary
	if c.focusActive {
		// Calculate the position of the focused message
		var focusedMsgTop int
		for i := 0; i < c.focusIndex; i++ {
			focusedMsgTop += messageHeights[i]
		}
		focusedMsgBottom := focusedMsgTop + messageHeights[c.focusIndex]

		// Only scroll if the focused message is not fully visible
		if focusedMsgBottom > c.viewport.YOffset+c.viewport.Height {
			// Message is below viewport - scroll down
			c.viewport.YOffset = focusedMsgBottom - c.viewport.Height
		} else if focusedMsgTop < c.viewport.YOffset {
			// Message is above viewport - scroll up
			c.viewport.YOffset = focusedMsgTop
		}
	} else {
		// When not focused, stay at bottom for new messages
		if totalHeight > c.viewport.Height {
			c.viewport.YOffset = totalHeight - c.viewport.Height
		}
	}
}

// View renders the chat view
func (c *ChatView) View() string {
	return chatStyle.Render(c.viewport.View())
}

================
File: internal/ui/finder_view.go
================
package ui

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/saiashirwad/gochat/internal/config"
)

// FinderView provides fuzzy search for chat history
type FinderView struct {
	config        *config.Config
	query         string
	results       []string // This would be replaced with actual chat results
	cursor        int
	width, height int
	style         lipgloss.Style
}

// NewFinderView creates a new finder view
func NewFinderView(cfg *config.Config) *FinderView {
	return &FinderView{
		config: cfg,
		style: lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("170")).
			Padding(1),
		results: []string{"Chat 1", "Chat 2", "Chat 3"}, // Placeholder results
	}
}

// SetSize updates the size of the finder view
func (f *FinderView) SetSize(width, height int) {
	f.width = width
	f.height = height
	f.style = f.style.Width(width - 2).Height(height - 2)
}

// Init initializes the finder view
func (f *FinderView) Init() tea.Cmd {
	// In a real implementation, this would load chat history
	return nil
}

// Update handles events for the finder view
func (f *FinderView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "up":
			if f.cursor > 0 {
				f.cursor--
			}
		case "down":
			if f.cursor < len(f.results)-1 {
				f.cursor++
			}
		case "enter":
			// Select the current chat
			// Would dispatch a command to load the selected chat
		}
	}
	return f, nil
}

// View renders the finder view
func (f *FinderView) View() string {
	var content string
	content += "Search: " + f.query + "\n\n"

	for i, result := range f.results {
		if i == f.cursor {
			content += "> " + result + "\n"
		} else {
			content += "  " + result + "\n"
		}
	}

	return f.style.Render(content)
}

================
File: internal/ui/input_view.go
================
package ui

import (
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/saiashirwad/gochat/internal/config"
)

var (
	// Style for the input box - no borders, subtle background
	inputBoxStyle = lipgloss.NewStyle().
			Background(lipgloss.Color("233")).
			Padding(0, 1)

	// Style for the input text
	inputTextStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("205"))
)

// userInputMsg is sent when the user submits a message
type userInputMsg struct {
	input string
}

// InputView handles user input
type InputView struct {
	config    *config.Config
	input     string
	cursorPos int
	width     int
	focused   bool
}

// NewInputView creates a new input view
func NewInputView(cfg *config.Config) *InputView {
	return &InputView{
		config:  cfg,
		input:   "",
		focused: true,
	}
}

// SetWidth updates the width of the input view
func (i *InputView) SetWidth(width int) {
	i.width = width
	inputBoxStyle = inputBoxStyle.Width(width - 2)
}

// Init initializes the input view
func (i *InputView) Init() tea.Cmd {
	return nil
}

// Update handles events for the input view
func (i *InputView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	if !i.focused {
		return i, nil
	}

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			i.focused = false
			return i, func() tea.Msg {
				return focusChatsMsg{}
			}
		case "enter":
			if i.input != "" {
				input := strings.TrimSpace(i.input)
				if input != "" {
					// Clear the input
					oldInput := i.input
					i.input = ""
					i.cursorPos = 0
					// Return the message as a command
					return i, func() tea.Msg {
						return userInputMsg{input: oldInput}
					}
				}
			}
			return i, nil
		case "shift+enter":
			// Insert newline at cursor position
			i.input = i.input[:i.cursorPos] + "\n" + i.input[i.cursorPos:]
			i.cursorPos++
		case "backspace":
			if i.cursorPos > 0 {
				// Remove character before cursor
				i.input = i.input[:i.cursorPos-1] + i.input[i.cursorPos:]
				i.cursorPos--
			}
		case "left":
			if i.cursorPos > 0 {
				i.cursorPos--
			}
		case "right":
			if i.cursorPos < len(i.input) {
				i.cursorPos++
			}
		default:
			// Handle all other characters including space
			if msg.Type == tea.KeyRunes {
				// Insert runes at cursor position
				i.input = i.input[:i.cursorPos] + string(msg.Runes) + i.input[i.cursorPos:]
				i.cursorPos += len(msg.Runes)
			}
		}
	}
	return i, nil
}

// View renders the input view
func (i *InputView) View() string {
	if !i.focused {
		return ""
	}

	// Add cursor to input
	displayText := i.input
	if i.cursorPos < len(displayText) {
		displayText = displayText[:i.cursorPos] + "│" + displayText[i.cursorPos:]
	} else {
		displayText = displayText + "│"
	}

	return inputBoxStyle.Render(
		inputTextStyle.Render(displayText),
	)
}

// Focus sets the input view as focused
func (i *InputView) Focus() {
	i.focused = true
}

// Blur removes focus from the input view
func (i *InputView) Blur() {
	i.focused = false
}

================
File: internal/ui/styles.go
================
package ui

import (
	"github.com/charmbracelet/lipgloss"
)

var (
	// Common styles
	appStyle = lipgloss.NewStyle().
		Margin(1, 2)

	// Message styles
	userMsgStyle = lipgloss.NewStyle().
		Foreground(lipgloss.Color("86")).
		Bold(true)

	botMsgStyle = lipgloss.NewStyle().
		Foreground(lipgloss.Color("170"))

	// Input styles
	inputPromptStyle = lipgloss.NewStyle().
		Foreground(lipgloss.Color("63")).
		Bold(true)

	// Title styles
	titleStyle = lipgloss.NewStyle().
		Background(lipgloss.Color("62")).
		Foreground(lipgloss.Color("230")).
		Padding(0, 1).
		Bold(true)
)

================
File: .air.toml
================
root = "."
tmp_dir = "tmp"

[build]
cmd = "go build -o ./bin/gochat ./cmd/gochat/main.go"
bin = "./bin/gochat"
full_bin = "GOCHAT_LLM_API_KEY=${GROQ_API_KEY} ./bin/gochat"
include_ext = ["go", "yaml"]
exclude_dir = ["bin", "tmp", "vendor", "chats"]
delay = 1000 # ms
kill_delay = "0.5s"
log = "build-errors.log"
send_interrupt = true
stop_on_error = true

[log]
time = true

[color]
main = "yellow"
watcher = "cyan"
build = "green"
runner = "magenta"

================
File: .cursorrules
================
# Cursor Rules for Go TUI LLM Chat App (Charm/Bubble Tea)
# Inspired by AI-First Development Guidelines
# Includes hints for Chat Persistence, Branching, Fuzzy Finding, and Streaming

# --- Application Summary (Embedded as Comments - For Human Reference Only) ---
#
# This project is a terminal-based LLM chat application built with Go and
# the Charm TUI libraries (Bubble Tea, Lip Gloss). It is designed to be
# powerful, fast, developer-friendly, and AI-first.
#
# Core Features:
#   - TUI Experience: Runs entirely in the terminal using Bubble Tea, styled
#     with Lip Gloss, providing a responsive, keyboard-driven interface.
#   - LLM Interaction: Supports multiple LLM providers (via config), features
#     a standard chat interface, and efficiently streams responses for
#     immediate feedback.
#   - Chat Management:
#       - Persistence: Saves/loads chat history locally as JSON files.
#       - Branching: Allows creating new chat branches from specific points
#         in existing conversations.
#       - Fuzzy Finder: Provides instant search and switching between saved
#         chats within the TUI.
#   - Rich Content: Capable of displaying images inline within the chat view
#     using terminal graphics protocols (loaded asynchronously).
#   - Performance: Optimized for speed and low latency using Go. All blocking
#     operations (LLM, I/O) are asynchronous (goroutines/channels) to keep
#     the UI responsive. Rendering is efficient.
#   - Architecture: Modular design with distinct packages (ui, llm, chat,
#     persistence, finder, config).
#   - Configuration: Uses external files (e.g., YAML) for settings like API
#     keys (via env vars), models, storage paths, etc.
#
# --- End of Application Summary Comment Block ---


# Version of the rules format
version: 1

# General rules for the project
# (These structured rules below are what Cursor primarily uses)
rules:
  # Language identifier
  - language: go
    description: "Project language is Go. Adhere to idiomatic Go practices."

  # --- Architectural & Performance Priorities ---
  # Emphasize asynchronous operations and core application logic.
  - pattern: "main.go"
    priority: 1.0 # Highest priority
    description: "Main application entry point. Expect initialization of Bubble Tea, config loading, chat loading/persistence setup, and potentially signal handling."

  - pattern: "**/*_cmd.go" # Files defining tea.Cmd functions
    priority: 0.95
    description: "CRITICAL: Asynchronous command handlers. Ensure non-blocking operations (LLM, Image I/O, Chat Save/Load, etc.) are implemented here using goroutines and channels, returning results via tea.Msg."

  - pattern: "**/*_model.go" # Files defining tea.Model implementations
    priority: 0.9
    description: "Core TUI state management (Bubble Tea models). Focus on efficient state updates, managing chat history, and separation of concerns."

  - pattern: "**/*_msg.go" # Files defining tea.Msg types
    priority: 0.85
    description: "Message definitions for communication between components and async tasks (including chat operations, finder results). Keep messages concise."

  # --- Module Priorities (Based on common Go project structure) ---
  - pattern: "**/internal/ui/**/*.go" # Primary location for UI components
    priority: 0.85
    description: "UI components (Bubble Tea & Lip Gloss). Includes chat view, input areas, and potentially the fuzzy finder UI. Focus on efficient rendering and component composition."
  - pattern: "**/components/**/*.go" # Alternative location for UI components
    priority: 0.85
    description: "UI components (Bubble Tea & Lip Gloss)."
  - pattern: "**/views/**/*.go" # Another alternative location for UI components
    priority: 0.85
    description: "UI components (Bubble Tea & Lip Gloss)."

  - pattern: "**/internal/llm/**/*.go" # LLM interaction logic
    priority: 0.85 # Slightly increased priority due to streaming focus
    description: "Logic for interacting with LLM APIs. MUST be asynchronous. Implement efficient text streaming responses. Handle API keys securely via config."
  - pattern: "**/llm/*.go"
    priority: 0.85
    description: "Logic for interacting with LLM APIs (alternative location)."

  # Prioritize Chat Persistence & Branching Logic
  - pattern: "**/internal/chat/**/*.go"
    priority: 0.88
    description: "Logic related to chat data structures, history management, saving/loading chats (JSON), and branching functionality."
  - pattern: "**/internal/persistence/**/*.go" # Alternative/specific persistence package
    priority: 0.88
    description: "Handles saving and loading application state, particularly chat history to JSON files."
  - pattern: "**/storage/*.go" # Another possible location
    priority: 0.85
    description: "Code related to file storage, likely including chat JSON files."

  # Prioritize Fuzzy Finder Logic
  - pattern: "**/internal/finder/**/*.go"
    priority: 0.80
    description: "Implementation of the fuzzy finder logic for searching and switching between chats."
  - pattern: "**/internal/ui/finder/**/*.go" # Finder UI component
    priority: 0.82
    description: "Bubble Tea component specifically for the fuzzy finder UI."

  - pattern: "**/internal/image/**/*.go" # Image handling logic
    priority: 0.75
    description: "Logic for loading, decoding, and preparing images for TUI display. MUST be asynchronous. Consider terminal graphics protocols (Sixel, etc.)."
  - pattern: "**/image/*.go"
    priority: 0.75
    description: "Logic for image handling (alternative location)."

  - pattern: "**/internal/config/**/*.go" # Configuration loading/management code
    priority: 0.8
    description: "Go code for loading and managing application configuration (e.g., using Viper). Load config early, provide access via structs."
  - pattern: "**/config/*.go"
    priority: 0.8
    description: "Go code for configuration (alternative location)."

  - pattern: "**/internal/utils/**/*.go" # Utility functions
    priority: 0.6
    description: "Shared utility functions. Keep them focused and well-defined."
  - pattern: "**/utils/*.go"
    priority: 0.6
    description: "Utility functions (alternative location)."

  # --- Configuration File Priorities ---
  - pattern: "config.yaml" # Common config file names
    priority: 0.9
    description: "Primary YAML configuration file. Expect definitions for LLM providers, models, API keys (via env refs), UI settings, chat storage paths."
  - pattern: "config.toml"
    priority: 0.9
    description: "Primary TOML configuration file."
  - pattern: "chats/**/*.json" # Location of saved chat files
    priority: 0.5 # Lower priority, but good for context on chat structure
    description: "Directory likely containing saved chat history in JSON format."
  - pattern: "configs/**" # Config directory
    priority: 0.88
    description: "Directory containing configuration files."
  - pattern: "config/**" # Alternative config directory
    priority: 0.88
    description: "Directory containing configuration files."
  - pattern: "**/*.yaml" # Any YAML file
    priority: 0.7
    description: "Potential configuration files in YAML format."

  # --- Library & Technology Focus ---
  # Emphasize files using core TUI, concurrency, config, and JSON libraries
  - pattern: "**/*.go"
    contains: ["github.com/charmbracelet/bubbletea", "tea.Model", "tea.Update", "tea.View", "tea.Cmd", "tea.Msg"]
    priority: 0.95 # Very high priority for core TUI logic
    description: "Core Bubble Tea implementation files. Ensure Update loop is non-blocking and View method is fast."

  - pattern: "**/*.go"
    contains: ["github.com/charmbracelet/lipgloss"]
    priority: 0.75
    description: "Files using Lip Gloss for styling. Define styles efficiently."

  - pattern: "**/*.go"
    contains: ["github.com/spf13/viper"]
    priority: 0.8
    description: "Files using Viper for robust configuration management."

  - pattern: "**/*.go"
    contains: ["encoding/json"] # JSON handling for chats
    priority: 0.85
    description: "Files handling JSON marshalling/unmarshalling, likely for chat persistence."

  - pattern: "**/*.go"
    contains: ["sync.Mutex", "sync.RWMutex", "chan", "context.Context", "go func"]
    priority: 0.85 # High priority for concurrency primitives
    description: "Files using Go's concurrency tools. Ensure proper use of channels for UI communication and context for cancellation."

  - pattern: "**/*.go"
    contains: ["os.Getenv", "os.ReadFile", "os.WriteFile"] # Env vars and File I/O
    priority: 0.75
    description: "Files reading environment variables or performing file I/O (config, chat persistence)."

  # Add focus for potential fuzzy finder libraries (example - adjust if using a specific one)
  # - pattern: "**/*.go"
  #   contains: ["github.com/ktr0731/go-fuzzyfinder"] # Example library
  #   priority: 0.80
  #   description: "Files using a fuzzy finding library."


  # --- Deprioritize/Ignore ---
  # Ignore build artifacts, vendor directories, tests, etc.
  - pattern: "bin/**"
    priority: 0.1
    description: "Ignore compiled binaries."
  - pattern: "vendor/**"
    priority: 0.1
    description: "Ignore vendored dependencies."
  - pattern: "**/*_test.go"
    priority: 0.3 # Lower priority for AI focus, but tests are important for the project
    description: "Go test files."
  - pattern: "testdata/**"
    priority: 0.1
    description: "Ignore test data."
  - pattern: "**/mocks/**" # Ignore generated mocks
    priority: 0.1
    description: "Ignore mock files."
  - pattern: ".git/**"
    priority: 0.0 # Ignore
    description: "Ignore Git internal files."

  # --- Context Strategy Hints (Guiding AI Focus) ---
  - context:
      strategy: "symbols"
      focus: [
          "tea.Model", "tea.Update", "tea.View", "tea.Cmd", "tea.Msg", # Bubble Tea Core
          "lipgloss.Style", "lipgloss.NewStyle", # Styling
          "viper.Get", "viper.Unmarshal", # Config
          "json.Marshal", "json.Unmarshal", # JSON Persistence
          "context.Context", "context.WithCancel", # Concurrency
          "make(chan", # Channels
          # Add specific types if known: e.g., "ChatMessage", "ChatHistory", "FinderModel"
          "SaveChat", "LoadChat", "BranchChat", "SwitchChat", # Key functions
      ]
      description: "Focus AI understanding on core TUI types, config/JSON methods, concurrency primitives, and key functions for chat ops/finding."

  - context:
      strategy: "imports"
      focus: [
          "github.com/charmbracelet/bubbletea",
          "github.com/charmbracelet/lipgloss",
          "github.com/spf13/viper",
          "encoding/json",
          "golang.org/x/net/context",
          "sync",
          "os",
          "io/fs", # Filesystem operations
          # Add imports for specific LLM client libs, image libs, or fuzzy finder libs used
      ]
      description: "Pay attention to imports related to TUI, config, JSON, concurrency, OS/FS interaction, and key external libraries."

  - context:
      strategy: "keywords"
      focus: [
          "go func", "chan", "select", "context", "async", "non-blocking", # Concurrency/Async
          "stream", "chunk", "buffer", "API", "LLM", "model", "prompt", # AI/LLM & Streaming
          "render", "style", "view", "update", # TUI
          "config", "LoadConfig", "Getenv", "APIKey", "Endpoint", # Config
          "save", "load", "persist", "storage", "json", "marshal", "unmarshal", "branch", # Persistence & Branching
          "fuzzy", "finder", "filter", "match", "search", "switch", # Fuzzy Finder
          "image", "decode", "sixel", "graphics", # Image Handling
          "error", "handle", "wrap", # Error Handling
          "performance", "optimize", "latency", "efficient", # Performance Concepts
      ]
      description: "Look for keywords related to core concepts: concurrency, TUI loop, LLM/streaming, config, persistence/branching, fuzzy finding, images, errors, and performance."

# --- Optional: Code Generation Hints (Reflecting Guidelines & Features) ---
# code_generation:
#   style_guide: "Effective Go"
#   preferred_patterns:
#     - "Use tea.Cmd for ALL blocking I/O (LLM, Image, File Save/Load)."
#     - "Communicate results back to Update via tea.Msg using channels."
#     - "Keep tea.Update and tea.View methods fast and non-blocking."
#     - "Implement efficient text streaming from LLM responses."
#     - "Save/Load chat history asynchronously using JSON."
#     - "Implement chat branching by copying relevant history."
#     - "Develop an interactive fuzzy finder component for chat switching."
#     - "Wrap errors with context using fmt.Errorf(... %w ...)."
#     - "Use context.Context for cancellation of background tasks."
#     - "Load configuration via Viper/structs, read secrets from environment variables."
#     - "Structure code into logical packages (internal/ui, internal/llm, internal/chat, internal/finder etc.)."
#   avoid_patterns:
#     - "Blocking calls directly in tea.Update or tea.View."
#     - "Goroutines without proper channel communication back to the UI loop."
#     - "Hardcoding API keys, endpoints, file paths, or sensitive configuration."
#     - "Ignoring errors returned from functions (especially I/O and JSON parsing)."
#     - "Inefficient handling of large chat histories in memory or during rendering."
#     - "Large, monolithic packages or functions."

================
File: config.yaml
================
llm:
  provider: groq
  model: deepseek-r1-distill-qwen-32b
  max_tokens: 2000
  # API key should be set via GOCHAT_LLM_API_KEY environment variable
  endpoint: "https://api.groq.com/openai/v1/chat/completions"

ui:
  theme: default
  max_width: 100
  show_timestamp: true

storage:
  chats_dir: ./chats

================
File: go.mod
================
module github.com/saiashirwad/gochat

go 1.21

require (
	github.com/charmbracelet/bubbles v0.18.0
	github.com/charmbracelet/bubbletea v0.25.0
	github.com/charmbracelet/glamour v0.6.0
	github.com/charmbracelet/lipgloss v0.9.1
	github.com/spf13/viper v1.18.2
)

require (
	github.com/alecthomas/chroma v0.10.0 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/containerd/console v1.0.4-0.20230313162750-1ae8d489ac81 // indirect
	github.com/dlclark/regexp2 v1.4.0 // indirect
	github.com/fsnotify/fsnotify v1.7.0 // indirect
	github.com/gorilla/css v1.0.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mattn/go-isatty v0.0.18 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.15 // indirect
	github.com/microcosm-cc/bluemonday v1.0.21 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/muesli/ansi v0.0.0-20211018074035-2e021307bc4b // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/reflow v0.3.0 // indirect
	github.com/muesli/termenv v0.15.2 // indirect
	github.com/olekukonko/tablewriter v0.0.5 // indirect
	github.com/pelletier/go-toml/v2 v2.1.0 // indirect
	github.com/rivo/uniseg v0.4.6 // indirect
	github.com/sagikazarmark/locafero v0.4.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.11.0 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/yuin/goldmark v1.5.2 // indirect
	github.com/yuin/goldmark-emoji v1.0.1 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.9.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/net v0.19.0 // indirect
	golang.org/x/sync v0.5.0 // indirect
	golang.org/x/sys v0.15.0 // indirect
	golang.org/x/term v0.15.0 // indirect
	golang.org/x/text v0.14.0 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: Makefile
================
.PHONY: build run clean test deps

# Binary name and path
BINARY_NAME=gochat
BINARY_PATH=bin/$(BINARY_NAME)

# Go related variables
GOBASE=$(shell pwd)
GOBIN=$(GOBASE)/bin

# Main package path
MAIN_PACKAGE=cmd/gochat/main.go

# Build variables
BUILD_TIME=$(shell date +%FT%T%z)
GIT_COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
VERSION?=dev

# Environment variables
export GOCHAT_LLM_API_KEY?=$(GROQ_API_KEY)

# Default target
all: clean build

# Build the application
build:
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(GOBIN)
	@go build -o $(BINARY_PATH) $(MAIN_PACKAGE)
	@echo "Build complete"

# Run the application
run: build
	@echo "Running $(BINARY_NAME)..."
	@$(BINARY_PATH)

# Run with hot reload (requires air: go install github.com/cosmtrek/air@latest)
dev:
	@if ! command -v air > /dev/null; then \
		echo "Installing air..."; \
		go install github.com/cosmtrek/air@latest; \
	fi
	@air -c .air.toml

# Clean build artifacts
clean:
	@echo "Cleaning..."
	@rm -rf $(GOBIN)
	@go clean
	@echo "Clean complete"

# Download and tidy dependencies
deps:
	@echo "Downloading dependencies..."
	@go mod download
	@go mod tidy
	@echo "Dependencies updated"

# Run tests
test:
	@echo "Running tests..."
	@go test -v ./...

# Show help
help:
	@echo "Available targets:"
	@echo "  make          - Clean and build the application"
	@echo "  make build    - Build the application"
	@echo "  make run      - Build and run the application"
	@echo "  make dev      - Run with hot reload (requires air)"
	@echo "  make clean    - Remove build artifacts"
	@echo "  make deps     - Download and tidy dependencies"
	@echo "  make test     - Run tests"
	@echo "  make help     - Show this help message"
